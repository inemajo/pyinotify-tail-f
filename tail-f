#!/usr/bin/python

import os
import pyinotify

BUFSIZE = 4096
    
class inoproc(pyinotify.ProcessEvent):

    def __init__(self, file_path):
        index = file_path.rfind('/')
        if index == -1:
            self.__file_name = file_path
            self.__file_dir = '.'
        else:
            self.__file_name = file_path[index+1:]
            self.__file_dir = file_path[:index]

        self.__filename = self.__file_dir + '/'  + self.__file_name
        self.stream = ''
        self.open_file()

    def open_file(self):
        self.__filefd = os.open(self.__filename, os.O_RDONLY)
        self.__nbr = 0

    def close_file(self):
        os.close(self.__filefd)
        
    def getfile_fd(self):
        return (self.__filefd)

    def __read_file(self):
        global BUFSIZE

        stats = os.stat(self.__filename)

        ##
        ## FIXME : when file is truncated and new data is equal or bigger than
        ##         current seek impossible to know if file is truncated
        if stats.st_size == self.__nbr:
            return
        elif stats.st_size < self.__nbr: # file truncated
            self.close_file()
            self.open_file()

        os.lseek(self.__filefd, self.__nbr, os.SEEK_SET)
        buff = os.read(self.__filefd, BUFSIZE)

        self.stream += buff
        self.__nbr += len(buff)
        return

    def getdir(self):
        return (self.__file_dir)

# --- Inotify bindings ----

    def process_IN_MODIFY(self, event):
        if self.__file_name != event.name or self.__file_dir != event.path:
            return
        self.__read_file()
    
    def process_IN_MOVE_SELF(self, event):
        # "The file moved! Continuing to read from that, until a new one is created.."
        return

    def process_IN_CREATE(self, event):
        if self.__file_name != event.name or self.__file_dir != event.path:
            return
        self.close_file()
        self.open_file()
        self.__read_file()
        return

class   tail(pyinotify.Notifier):

    def __init__(self, file_path, real_tail = False):


        if real_tail == True:
            self.__real_tail = True
            self.__create_tail(file_path)
        else:
            self.__real_tail = False
            dirmask = pyinotify.IN_MODIFY | pyinotify.IN_MOVE_SELF | pyinotify.IN_CREATE

            wm = pyinotify.WatchManager()
            self.ip = inoproc(file_path)
            wm.add_watch(self.ip.getdir(), dirmask)
            pyinotify.Notifier.__init__(self, wm, self.ip)

    def __create_tail(self, filename):
        from subprocess import Popen, PIPE

        self.__process = Popen(['tail', '-f', filename], stdout=PIPE)
        return

    def getfile(self):
        if self.__real_tail:
            return self.__process.stdout
        return self.ip.getfile_fd()

    def close(self):
        if self.__real_tail == True:
            self.__process.terminate()
        else:
            self.ip.close_file()

    def read_stream(self):
        if self.__real_tail == True:
            return self.__process.stdout.readline()
        result = self.ip.stream
        self.ip.stream = ''
        return result

if __name__ == "__main__":
    import sys
    import select
    import signal

    def p(notifier):
        os.write(1, notifier.read_stream())

    def __signal_handler(sig, frame, notifier):
        notifier.ip.close_file()
        notifier.ip.open_file()

    signal.signal(signal.SIGUSR1, lambda s, f : __signal_handler(s, f, notifier))
    
    if len(sys.argv) == 3 and sys.argv[2] == 'real':
        real = True # start with a pipe to real tail
    else:
        real = False # start class instance

    notifier = tail(sys.argv[1], real)
    while True:
        try:
            select.select([notifier.getfile()], [], [])
            if real == False:
                if notifier.check_events():
                    notifier.read_events()
                    notifier.process_events()
            p(notifier)
        except KeyboardInterrupt:
            break

    if real == False:
        notifier.stop()
    sys.exit(0)
